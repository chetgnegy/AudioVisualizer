/*
 * signal.h
 *
 *  Created on: Sep 24, 2013
 *      Author: chetgnegy
 */
#include <stdio.h>
#include <stdlib.h>

#ifndef SIGNAL_H_
#define SIGNAL_H_

#ifndef SAMPLE_RATE
#define SAMPLE_RATE 44100.0
#endif
#ifndef PI
#define PI 3.14159265358979
#endif
#ifndef TWOPI
#define TWOPI 6.2831853072
#endif




/*
 * A data packet. This class is an argument to the signals in fourierJukebox.cpp and allows them to be called uniformly
 * whether or not the functions actually require the width parameter.
 */
class SignalData{
public:
	double phase;
	double width;
	double freq;
	SignalData(double, double, double);
};

SignalData::SignalData(double p, double w, double f){
	phase = p;
	width = w;
	freq = f;
}
class Signal {
public:
	double (*fun)(SignalData);
	double freq;
	double amplitude;
	double phaseOffset;
	Signal(double (*fun)(SignalData), double);
	Signal(double (*fun)(SignalData), double, double);
	Signal(double (*fun)(SignalData), double, double, double);
	void setWidth(double);
	double getWidth(void);
private:
	double width;//only used for square waves


};

/*A simple constructor that allows us to specify only the function and frequency*/
Signal::Signal(double (*fnc)(SignalData), double f) {
	fun = fnc;
	freq = f;
	amplitude = 1;
	phaseOffset = 0;
	width = .5;
}

/*A constructor that allows us to specify the function, frequency, and amplitude*/
Signal::Signal(double (*fnc)(SignalData), double f, double a) {
	fun = fnc;
	freq = f;
	amplitude = a;
	phaseOffset = 0;
	width = .5;

}
/*A constructor that allows us to specify the function, frequency, amplitude, and phase*/
Signal::Signal(double (*fnc)(SignalData), double f, double a, double p) {
	fun = fnc;
	freq = f;
	amplitude = a;
	phaseOffset = p;
	width = .5;
}


void Signal::setWidth(double w){
	width = w;
}

/*Any width can be specified, but upon recall only widths that are small or large enough to actually produce
 * a signal are valid. An impulse train can be generated by setting width to zero. As the frequency is updated,
 * the signal will continue to ensure that the duty cycle remains greater than zero and less than one, exclusive.*/
double Signal::getWidth(void){
	double minWidth = freq / (1.0*SAMPLE_RATE+0.1);
	if (width<minWidth) return minWidth;
	if (width>1-minWidth) return 1- minWidth;
	return width;
}




/*
 * Uses pulse to generate an impulse. This is guaranteed to be a single sample by setting the width to a minimum.
 * See Signal::getWidth() for more details
 */
double impulse(SignalData data) {
	//Additive synthesis square wave
	double sum = 0;
	double n = 1;
	double nPi, coeff;

	while (data.freq * n < SAMPLE_RATE && n < 20) {
		nPi = n * PI;
		coeff = sin(data.width * nPi) / nPi;
		sum += coeff * cos(n * data.phase);
		n += 1;
	}
	return 2 * (data.width / 2.0 + sum);
	//The naive way.
	//double mod_p = (data.phase - (int) (data.phase / (TWOPI)) * TWOPI); //remove multiples of 2pi
	//return (mod_p < TWOPI * data.width) ? 1 : -1;
}

/* A rectangular pulse is generated with high value of 1 and low value of -1. The width changes the duty cycle.
 * The function is guaranteed to have greater than DC frequency by the way the bounds on width are established.
 * See Signal::getWidth() for more details. Additive synthesis is used to prevent aliasing.
 */
double pulse(SignalData data) {
	//Additive synthesis square wave
	double sum = 0;
	double n = 1;
	double nPi, coeff;

	while (data.freq * n < SAMPLE_RATE && n < 15) {
		nPi = n * PI;
		coeff = sin(data.width * nPi) / nPi;
		sum += coeff * cos(n * data.phase);
		n += 1;
	}
	return 4 * (data.width / 2.0 + sum) - 1;
	//The naive way.
	//double mod_p = (data.phase - (int) (data.phase / (TWOPI)) * TWOPI); //remove multiples of 2pi
	//return (mod_p < TWOPI * data.width) ? 1 : -1;
}

/*
 * A sine wave, thanks to the math library. Peaks at +/-1
 */
double sin(SignalData data) {
	return sin(data.phase);
}
/*
 * A sawtooth wave is generated with peak values of 1 and -1. The width changes the length of the
 * increasing/decreasing sections of the signal. A width of .5 is a triangle wave. Additive synthesis is used to prevent aliasing.
 */
double saw(SignalData data) {
	//Additive synthesis triangle wave
	double sum = 0, sum_n = 0;
	double n = 1;
	double nPi, coeff;

	//Precalculating things that happen a lot
	double w_inv = 1 / data.width;
	double wneg_inv = 1 / (data.width - 1);
	double ww = 2 * data.width;
	double ww_neg = 2 * (data.width - 1);

	while (data.freq * n < SAMPLE_RATE && n < 15) {
		nPi = n * PI;
		sum_n = 0;

		//the even terms
		coeff = wneg_inv * (cos(ww_neg * nPi) - 1) - w_inv * (cos(ww * nPi) - 1);
		sum_n += coeff * cos(n * data.phase);

		//The odd terms
		coeff = wneg_inv * sin(ww_neg * nPi) - w_inv * sin(ww * nPi);
		sum_n += coeff * sin(n * data.phase);

		sum += sum_n / (n * n);

		n += 1;
	}
	return sum / PI / PI;

	//The naive way.
	/*
	 double mod_p = (data.phase - (int) (data.phase / (TWOPI)) * TWOPI); //remove multiples of 2pi
	 double transition = TWOPI * data.width;
	 if (mod_p < transition) { //increasing part of function
	 return mod_p * 2.0 / transition - 1;
	 }
	 else {
	 return 1 - (mod_p - transition) / (TWOPI - transition) * 2.0;
	 }*/
}

/*
 * Random, uncorrelated noise. The stuff of nightmares. Parameters are only there to use polymorphic function.
 * Signal peaks at +/- 1.
 */
double noise(SignalData data) {
	return 2.0 * rand() / RAND_MAX - 1.0;
}


#endif /* SIGNAL_H_ */
